<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>optar</title>
<style>
  body{font-family:system-ui, sans-serif; margin:2rem}
  button{margin-top:1rem}
  #log{white-space:pre-wrap; font-size:.8rem; background:#f6f6f6; padding:.5rem; max-height:12rem; overflow:auto}
</style>
</head>
<body>

<h1>OPTAR (OPTical ARchiver)</h1>
<p style="color:#bbb">*WebAssembly used, no server side processing. Files are not uploaded to any servers, preserving your privacy.</p>
<p>Backup any file with printable paper copies. Note that file sizes are not preserved and there is often a small (~1-10%) irreparable error rate, so use archive formats (like rar with recovery records or par2 for builtin parity) or files where partial recovery is useful (such as txt or ogg video files). Originally made by <a href=https://ronja.twibright.com/optar/ target=_blank>Twibright Labs</a>.</p>
<p>Use <a href=unoptar.html>unoptar</a> to decode scanned optar PNGs (only supports 32x46 x/ycrosses values at the moment which encodes ~50KB per A4 page)</p>
<form>
<input type="file" id="optarFileInput">
<button id="runBtn" disabled>Run optar</button>
<nbsp>
<span>xcrosses: <input type="number" id="xcrosses" value=32 placeholder="32" style="width: 3em">
ycrosses: <input type="number" id="ycrosses" value=46 placeholder="46" style="width: 3em"></span> <abbr title="a bigger x y value will increase the amount of data encoded on a page (e.g. 65 93 will encode 200KB per A4 page), but will need more powerful printers and scanners (1200+dpi). The default 32 46 encodes 50KB per page.">
 <span>&#xFE56;<span/></abbr>
<input type="reset"/>
</span>

<div id="log">Log (open console for more): <br></div>


<!-- 1. Emscripten glue for optar -->
<script src="./wasm/optar.js"></script>
<!-- <script src="./imagemagick/package/dist/bundles/magickApi.js" ></script> -->

<script type='module'>
import * as Magick from "./imagemagick/package/dist/bundles/magickApi.js";

function MagickCall(...args) {
  return Magick.call(...args);
}

window.MagickCall = MagickCall;

</script>

<script>

const log = (...args) => {
  const box = document.getElementById('log');
  box.textContent += args.join(' ') + '\n';
  box.scrollTop = box.scrollHeight;
};
const downloadBlob = (blob, name) => {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  URL.revokeObjectURL(a.href);
};


const fileInput = document.getElementById('optarFileInput');
const runBtn    = document.getElementById('runBtn');
const xInput = document.getElementById('xcrosses');
const yInput = document.getElementById('ycrosses');
runBtn.disabled = !fileInput.files.length;

fileInput.addEventListener('change', () => {
  runBtn.disabled = !fileInput.files.length;
});


runBtn.addEventListener('click', async () => {
  runBtn.disabled = true;
  log('\nStarting... (please refresh the page before encoding another file)');

  const file = fileInput.files[0];
  if (!file) {
    log("no file input..");
  }
  const FS = this.FS;
  const fileNameSanitized = file.name.replace(/[^a-z0-9_.-]/gi, '_');
  const buf = await file.arrayBuffer();

  var reader = new FileReader();
  reader.onload = async function() {
    const fileContentArray = new Uint8Array(this.result);

    FS.writeFile('/' + fileNameSanitized, fileContentArray);
    log('wrote', fileNameSanitized, 'to MEMFS');

    var xval = "32";
    var yval = "46";
    if ((xInput.value != "") && (yInput.value != "")) {
      xval = xInput.value;
      yval = yInput.value;
    }
    run(['/'+fileNameSanitized, fileNameSanitized, xval, yval]);
    log('optar finished');

    const outFiles = FS.readdir('/').filter(n => n.endsWith('.pgm'));
    if (!outFiles.length) { log('No .pgm files produced'); return; }

    /* ---------- 3. ImageMagick conversions ---------- */
    var pgmFilesContents = []; // array of {name: filename, content: filedata} to provide to wasm-imagemagick

    for (const pgmName of outFiles) {
      const pgmData   = FS.readFile('/' + pgmName); // FS.readFile returns an Uint8Array by default
      // const pgmBlob   = new Blob([pgmData], {type:'image/x-portable-graymap'});
      console.log(`${pgmName}:`,pgmData);
      pgmFilesContents.push({'name':pgmName, 'content':pgmData});
      // downloadBlob(pgmBlob, pgmName);
    }
    console.log(`running magick Call with pgmFilesContents: ${pgmFilesContents} and outFiles: ${outFiles}`);
    let magickResult = await window.MagickCall(pgmFilesContents, ["convert", ...outFiles, `${fileNameSanitized}.pdf`]);
    console.log('imagemagick result:', magickResult);
    const pdfBlob = magickResult.outputFiles[0]['blob'];
    downloadBlob(pdfBlob, `${fileNameSanitized}.pdf`);
    log('Done.');
    runBtn.disabled = false;

    return; 
  }
  reader.readAsArrayBuffer(file);
});

</script>
</body>
</html>
